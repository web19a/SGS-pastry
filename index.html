<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Sphere</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create sphere
        const geometry = new THREE.SphereGeometry(1, 32, 32);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x3498db,
            wireframe: true
        });
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        // Add small circles on surface
        const circleGeometry = new THREE.CircleGeometry(0.05, 16);
        const circleMaterial = new THREE.MeshBasicMaterial({ color: 0xff7e5f });
        
        function createCircularImageTexture(imagePath) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    
    // Load image
    const img = new Image();
    img.src = imagePath;
    img.onload = function() {
        // Draw circular mask
        ctx.beginPath();
        ctx.arc(128, 128, 128, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
        
        // Draw image
        ctx.drawImage(img, 0, 0, 256, 256);
    };
    
    return new THREE.CanvasTexture(canvas);
}
        // Create a texture loader
const textureLoader = new THREE.TextureLoader();
const photos = ['IMG_20250616_175904_245.jpg', 'IMG_20250616_175906_065.jpg', 'IMG_20250616_175907_726.jpg', 'IMG_20250616_175909_163.jpg', 'IMG_20250616_181934_297.jpg', 'IMG_20250616_181935_757.jpg'];
// Replace the circle creation loop with this:
for (let i = 0; i < 50; i++) {
    const randomIndex = Math.floor(Math.random() * photos.length);
    // Load your image (replace 'path/to/image.jpg' with your image path)
    const texture = createCircularImageTexture(photos[randomIndex]);
    
    // Create sprite material with the image texture
    const spriteMaterial = new THREE.SpriteMaterial({ 
        map: texture,
        transparent: true,
        opacity: 0.9
    });
    
    // Create sprite
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(0.2, 0.2, 1); // Adjust size as needed
    
    // Position on sphere surface (same as before)
    const phi = Math.acos(-1 + (2 * i) / 50);
    const theta = Math.sqrt(50 * Math.PI) * phi;
    
    sprite.position.set(
        Math.sin(phi) * Math.cos(theta),
        Math.sin(phi) * Math.sin(theta),
        Math.cos(phi)
    );
    
    // Scale to make them sit on the surface
    sprite.position.multiplyScalar(1.05);
    scene.add(sprite);
}

        camera.position.z = 5;

        // Interaction variables
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let autoRotate = true;
        let rotationSpeed = 0.005;

        // Event listeners
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                sphere.rotation.y += deltaX * 0.01;
                sphere.rotation.x += deltaY * 0.01;
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

        // Zoom with mouse wheel
        renderer.domElement.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = THREE.MathUtils.clamp(camera.position.z, 2, 10);
        });

        // Touch events for mobile
        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;
                
                sphere.rotation.y += deltaX * 0.01;
                sphere.rotation.x += deltaY * 0.01;
                
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });

        renderer.domElement.addEventListener('touchend', () => isDragging = false);

        // Pinch to zoom
        let initialPinchDistance = null;
        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                initialPinchDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const currentDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                
                const zoomFactor = initialPinchDistance / currentDistance;
                camera.position.z += (1 - zoomFactor) * 2;
                camera.position.z = THREE.MathUtils.clamp(camera.position.z, 2, 10);
                
                initialPinchDistance = currentDistance;
            }
        });

        // Tap to pause/play
        renderer.domElement.addEventListener('click', () => {
            autoRotate = !autoRotate;
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                sphere.rotation.y += rotationSpeed;
            }
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
